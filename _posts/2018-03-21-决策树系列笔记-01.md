---
title: 决策树系列笔记-01
key: 20180321
tags: 决策树 机器学习 GBDT 
---

最近，刚尝试了 kaggle，对 tree-based model 有了兴趣，发现这一类算法不仅在kaggle上广受好评，而且具有可解释性强、原理相对通俗易懂，而且经常和集成学习等结合，常常能发挥出优秀的效果。


#### 1. 决策树 (Decision Tree)
如果你学习了数据结构，tree这个结构想必你不会陌生，无疑是最重要的数据结构之一，决策树其实也不过是类似的结构：对于一棵已经训练好的树模型，输入从根节点出发，经过一系列的 if-else 选择之后，达到叶子节点从而得到了分类的结果，咋看之下似乎是只能用于分类的模型，但实际上经过改进是可以用到回归的，CART就是这么一种。
决策树的特点：
1、分类速度快，利用训练数据根据损失函数最小化建立模型，预测则对新的数据输入即可分类；
2、决策树同时表示给定特征条件下类的条件概率分布。
3、决策树的路径或者其对应的if-then 集合具有一个重要的性质：互斥并且完备；


##### 1. 决策树的生成
本质上，是从训练集中归纳出一组分类规则，因此可以生成的决策树可能有多个也可能一个都没有；通常是递归地选择最优特征，按照这一特征将训练数据集分割成子集，让每个子集在当前条件下有最好的分类，如果这些子集已经能够被基本正确分类，那么就可直接构建叶子节点并将这些子集分到对应的叶子节点中去，如果还不能，那么就对这些子集选择新的最优特征继续分；递归的进行下去，直到所有训练数据子集被基本分类正确或者没有合适的特征为止，最后每个子集都分类到叶子节点上，即训练集的每个$x$有了明确的分类。
这样子生成的决策树，绝对具有很好的分类能力——但是只是对训练数据而言，很容易联想到在测试集上可能泛化能力不好，因为这样一种高复杂度的模型容易发生过拟合，为此，对树进行剪枝是很重要的，减掉分得过于好的叶子节点回退到父节点（甚至继续回退也是可以）即降低模型的复杂度使之变得更简单。
特征选择问题：
先不说怎么剪枝，先来看看每次自当前节点，怎么选择这些特征进行分裂。
对于某个训练集，让我们说$y=\{-1,+1\}$好了，$x$可能存在多个特征，就以贷款为例，样本的年龄信贷情况都是特征，那么生成树的话每次怎么决定这些特征就是个问题。**一般一个特征具有更好的区分能力，或者说按照这一特征分割的子集使得在当前条件下有最好的分类那么就应该选择这个特征**。
信息论的一些 Prerequistive
定义概率分布$$P(X=x_i)=p_i，i=1,2,...n$$那么随机变量X的熵为$$H(X)=-\sum_{i=1}^n p_i\log p_i$$表示随机变量的不确定性。我们定义$0\log 0 =0$，其实也可以发现$H(p)$在概率为1和概率为0时熵是0。
对随机变量$(X,Y)$，其联合分布$P(X=x_i,Y=y_i)=p_{ij},i=1,2,...n,j=1,2,...m$，可以定义条件熵表示在已知随机变量$X$下$Y$的不确定性，定义为$H(Y|X)=\sum_{i=1}^n p_iH(Y|X=x_i)$，其中$p_i=P(X=x_i)$。**信息增益**表示得知特征$X$的信息而使类$Y$的信息的不确定性减少的程度。，这样很容易写出$$g(D,A)=H(D)-H(D|A)$$即是集合$D$的熵与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差，也常常称为mutual information，我们便可用这个来作为选择特征的准则——不确定性减少的程度，显然信息增益依赖于特征，不同的特征具有的信息增益不同，我们选**最大的**因为具有更强的分类能力。那么，对于某个训练集（或者子集），计算其每个特征的信息增益并比较他们的大小选择最大的那个特征。
假如给了你一个数据集$D$，和特征$A$，此时类有$\{C_1,C_2,...C_k\}$，那么你首先算他们的经验熵$H(D)$，就是$\frac{|C_i|}{|D|}$，就是第 i 类所占的比例，把 i 全部求和再取负号；再对于所有的特征$A_1,...A_k$都把信息增益$$g(D,A_i)=H(D)-H(D|A_i)$$算出来，选那一个再作为最有特征。这其实便是**ID3算法**的核心；我们定义再信息增益比(information gain ratio)可以作为另一个准则，他是$g(D,A)$和$D$关于特征$A$的熵$H_A(D)$之比，其中$$H_A(D)=-\sum_{i=1}^n\frac{|D_i|}{|D|}\log_2\frac{|D_i|}{|D|}$$其中$n$是特征$A$取值的个数，不过我们不再赘述了，他是另一决策树算法C4.5的准则。

ID3，从根节点开始，对节点计算所有可能特征的信息增益，选择信息增益最大的那个特征，作为节点的特征，由该特征不同取值（比如该特征可能是是或否，或者是分为$1...n$类，）建立子节点，再对子节点递归的调用以上方法（选择剩下的特征，用经过父节点分好类了的训练集$D_i$算增益。因此假如说你经过一次，选择$A_1$划分之后，子节点此时的数据集是$D_1$和$D_2$，那么你分别对这两个数据集算信息增益$g(D_1,A_2),g(D_1,A_3)...g(D_2,A_2),g(D_2,A_3)...$）继续构建，直到所有特征的信息增益很小或者没有特征可以继续使用为止。ID3对应的其实是概率模型上的极大似然。C4.5和ID3类似，只不过他用了上文所述的信息增益比来做，不再赘述。
##### 2. 决策树的剪枝(pruning)
树大必有枯枝，决策树也是如此，递归的算法生成的决策树我们可以在当某一个节点的信息增益比小于某个$\beta$时就结束分裂，不过这也不够。
总之根据以上方法产生的树往往对训练集分类很准确，但是对未知的测试集分类未必那么准确，导致overfitting，因为树过于复杂。解决方法就是简化之。
通常通过极小化决策树整体的损失函数来实现，设树$T$叶子节点个数为$|T|$，某个叶子$t$上有$N_t$个样本点，其中属于第$k$类的样本点有$N_{tk}$个，$H_t(T)$是$t$上的经验熵，$\alpha\ge0$是参数那么定义损失函数为$C_\alpha(T)=\sum_{t=1}^{|T|}N_tH_t(T)+\alpha|T|$。等号左边第一项，表示模型对训练数据的预测误差（或拟合程度），$|T|$表示模型的复杂度，参数$\alpha$控制两者之间的影响，即训练的好坏和模型大小之间的一种trade-off，你可以理解为**正则**！！显然$\alpha$小，那么较少地惩罚模型的复杂度，模型可以比较复杂；反之则是较多的惩罚和训练集的拟合程度，模型应当简化。
pruning即是当$\alpha$确定时选择损失函数最小的那个模型（即子树）。子树越大则模型越复杂，拟合程度越好；反之不述。可以说，决策树的生成学习局部模型，而pruning才是学习整体的模型。
**Pruning**
Input：生成的树 $T$，$\alpha$
Output：修剪后的子树$T_\alpha$
(1)计算所有节点的经验熵；
(2)递归地从树的叶子节点向上回缩；
(3)设一组叶子节点回缩到其父亲节点前后的整体树分别为$T_B,T_A$如果$C_\alpha(T_A)\le C_\alpha(T_B)$,也就是说如果剪枝后的损失比剪枝前小，那就进行剪枝——将父节点变为新的叶子节点，原叶子节点弃掉；
(4)返回(2)，直到不能再继续为止，得到$T_\alpha$
以上是决策树的prerequisite。
###一些总结：
决策树的特点：
容易理解；计算上效率高；还可以用来做集成学习。可能过拟合，需要剪枝，树的深度是超参数。

**引用**
1. 统计学习方法，李航
2. 机器学习技法，林轩田

